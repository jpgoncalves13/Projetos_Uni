<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Tarefa3</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa3</p></div><div id="description"><p class="caption">Description</p><div class="doc"><ul><li>O principal objetivo desta Tarefa &#233; converter um labirinto numa forma mais adequada para leitura, criando a fun&#231;&#227;o compactMaze.</li><li>Come&#231;&#225;mos por definir a fun&#231;&#227;o chooseIndCorr que dado uma lista de corredores e um corredor, escolhe a posi&#231;&#227;o onde um corredor se encontra, por exemplo se se encontrar na primeira posi&#231;&#227;o retorna o valor 0.
     Seguidamente, definimos a fun&#231;&#227;o convertToInstruct que transforma um corredor numa Instruction e a fun&#231;&#227;o instructToInstruct que dado uma lista de pares Int e Piece, se para dois elementos consecutivos as Pieces s&#227;o iguais, ent&#227;o vai se transformar num elemento em que a primeira componente vai ser composta pela Piece do primeiro par somado com um, e assim consecutivamente at&#233; percorrer a lista toda.
     Se os dois elementos consecutivos n&#227;o tiverem as Pieces iguais, ent&#227;o esses elementos v&#227;o ficar iguais.
     Por fim, fizemos a fun&#231;&#227;o compactMaze que transforma um labirinto numa lista de instru&#231;&#245;es.</li><li>Concluindo, o principal resultado obtido nesta tarefa foi a compacta&#231;&#227;o do labirinto para uma forma mais f&#225;cil de se ler.</li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:compactMaze">compactMaze</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li><li class="src short"><a href="#v:chooseIndCorr">chooseIndCorr</a> :: [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; Int</li><li class="src short"><a href="#v:convertToInstruct">convertToInstruct</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; <a href="Types.html#t:Instruction" title="Types">Instruction</a></li><li class="src short"><a href="#v:instructToInstruct">instructToInstruct</a> :: [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)] -&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:compactMaze" class="def">compactMaze</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a> <a href="#v:compactMaze" class="selflink">#</a></p><div class="doc"><p>Creates Intructions given a Maze   </p><p>The function verify if the last element belong to the rest of the list, and to this recursively     </p></div></div><div class="top"><p class="src"><a id="v:chooseIndCorr" class="def">chooseIndCorr</a> :: [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; Int <a href="#v:chooseIndCorr" class="selflink">#</a></p><div class="doc"><p>Calculates given a list of corridors and a corridor from that list, the position in which it is located, where the runner at the top of the list is in position 0 </p></div></div><div class="top"><p class="src"><a id="v:convertToInstruct" class="def">convertToInstruct</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; <a href="Types.html#t:Instruction" title="Types">Instruction</a> <a href="#v:convertToInstruct" class="selflink">#</a></p><div class="doc"><p>Given a corridor this function converts it to an Instruction</p></div></div><div class="top"><p class="src"><a id="v:instructToInstruct" class="def">instructToInstruct</a> :: [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)] -&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)] <a href="#v:instructToInstruct" class="selflink">#</a></p><div class="doc"><p>Given a list of pairs converts it into a list where the consecutive elements are equal, that is, where the Piece in the second element of the pair are the same in consecutives pairs of the list, come together </p><p>If the consecutive elements are equal we add on one to the first element of the pair where the function retains the first pair with the changes otherwise the first pair go to the head of the final list and to this recursively</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>